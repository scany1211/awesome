---

layout: post
title: 串一串一致性协议
category: 技术
tags: Distribute
keywords: 一致性协议

---

## 简介

* TOC
{:toc}

![](/public/upload/distribute/consistency.png)

事务一致性、副本一致性、leader-base、两阶段提交、强一致性、最终一致性 只是算法的某个特性，你可以说算法具有某种特性，但无需跟这些概念过分绑定。所以学习分布式协议，重点不是某个算法。而是为了达成需求 要解决m个问题，每个问题有n种方法，某个算法只是 在m*n 种组合的一种实现。

|两个维度|事务一致性|副本一致性|
|---|---|---|
|强一致性|XA/TCC|paxos/raft|
|最终一致性|消息补偿等|Gossip/Quorum NWR|

## 什么是一致性

一致性 可以看作是分布式系统对访问自己的客户端的一种承诺：不管你访问哪个节点，要么我给你返回的都是绝对一致的最新写入的数据，要么你读取失败。你可以看到，一致性强调的是数据正确。

1. 对客户端而言，每次读都能读取到（自己或他人）最新写入的数据（访问集群的任一节点）。
2. 从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。

数据一致性

1. 在数据库系统中，通常指关联数据之间的逻辑关系是否正确和完整。[条分缕析分布式：到底什么是一致性？](https://mp.weixin.qq.com/s/qnvl_msvw0XL7hFezo2F4w)比如转账的例子，“转账前后账户总额保持不变”，这个规定只对于「转账」这个特定的业务场景有效。如果换一个业务场景，「一致」的概念就不是这样规定了。所以说，ACID中的「一致性」，其实是体现了业务逻辑上的合理性，**并不是由数据库本身的技术特性所决定的**。
2. 在分布式系统中，指的是由于数据的复制，不同数据节点中的数据内容是否完整并且相同。

[条分缕析分布式：到底什么是一致性？](https://mp.weixin.qq.com/s/qnvl_msvw0XL7hFezo2F4w)论文Uniform Consensus Is Harder Than Consensus 原子提交问题（2pc/3pc）被抽象成一个新的一致性问题，称为uniform consensus问题，它是与通常的共识问题（consensus problem）不同的问题，而且是更难的问题。**uniform consensus，要求所有节点（包括故障节点）都要达成共识；而consensus问题只关注没有发生故障的节点达成共识**。

[分布式共识(Consensus)：Viewstamped Replication、Raft以及Paxos](http://blog.kongfy.com/2016/05/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86consensus%EF%BC%9Aviewstamped%E3%80%81raft%E5%8F%8Apaxos/)分布式共识问题，简单说，**就是在一个或多个进程提议了一个值应当是什么后，使系统中所有进程对这个值达成一致意见。** 这样的协定问题在分布式系统中很常用，比如说
1. 选主（Leader election）问题中所有进程对Leader达成一致；
2. 互斥（Mutual exclusion）问题中对于哪个进程进入临界区达成一致；
3. 原子组播（Atomic broadcast）中进程对消息传递（delivery）顺序达成一致。

对于这些问题有一些特定的算法，但是，**分布式共识问题试图探讨这些问题的一个更一般的形式，如果能够解决分布式共识问题，则以上的问题都可以得以解决。**

小结一下就是：一致性是一个结果，共识是一个算法，通常被用于达到一致性的结果。

在《区块链核心算法解析》中，则采用另一种描述方式：对于一组节点，如果所有节点均以相同的顺序执行一个（可能是无限的）命令序列c1,c2,c3...，则这组节点 实现了状态复制。

[《In Search of an Understandable Consensus Algorithm》](https://raft.github.io/raft.pdf)Consensus algorithms allow a collection of machines to work as a coherent group that can survive the fail- ures of some of its members. Because of this, they play a key role in building reliable large-scale software systems.

## 从容错性强弱的角度来串一下一致性协议

从容错性角度来串一下一致性协议

||表现|算法|
|---|---|---|
|无法容错|XA/TCC|当然，也可以采用一些补偿机制稍稍 容忍些超时类的问题|
|非拜占庭错误|节点故障或网络不通，只是收不到它的消息了，而不会收到来自它的错误消息。相反，只要收到了来自它的消息，那么消息本身是「忠实」的。|paxos|
|拜占庭错误|1. 叛徒的恶意行为，在不同的将军看来，叛徒可能发送完全不一致的作战提议。<br>2. 虽然并非恶意，出现故障（比如信道不稳定）导致的随机错误或消息损坏||
|拜占庭将军问题|叛徒发送前后不一致的作战提议，属于拜占庭错误；<br>而不发送任何消息，属于非拜占庭错误。|BTF|

BFT的算法应该可以解决任何错误下的分布式一致性问题，也包括Paxos所解决的问题。那为什么不统一使用BFT的算法来解决所有的分布式一致性问题呢？为什么还需要再费力气设计Paxos之类的一些算法呢？

1. 提供BFT这么强的错误容忍性，肯定需要付出很高的代价。比如需要消息的大量传递。
2. 对于运行环境的假设(assumption)，具体到Lamport在论文中给出的解决「拜占庭将军问题」的算法，它还对运行环境的假设(assumption)有更强的要求。比如BTF 有一条： The absence of a message can be detected ==> 依赖某种超时机制 ==> 各节点时钟同步 ==> 同步模型。

## 允许/不允许哪些操作顺序发生

[分布式系统中的一致性模型](https://mp.weixin.qq.com/s/_yJqXUIQ7ka8f46j3VCbuQ)一个系统是由状态和一些导致状态转移的操作组成的。在系统运行期间，它将随着操作的演进从一个状态转移到另一个状态。一致性模型是所有被允许的操作记录的集合。当我们运行一个程序，经过一系列集合中允许的操作，特定的执行结果总是一致的。如果程序意外地执行了非集合中的操作，我们就称执行记录是非一致的。如果任意可能的执行操作都在这个被允许的操作集合内，那么系统就满足一致性模型。

系统的状态可以是个变量，操作可以是对这个变量的读和写。一旦我们把变量写为某个值，比如a，那么读操作就应该返回a，直到我们再次改变变量。读到的值应该总是返回最近写入的值。我们把这种系统称为——单值变量——单一寄存器。并发会让一切表现的不同，如果我们用2个进程（top和bottom）运行这个并发程序
1. Top写入a，读到a，接着读到b——这不再是它写入的值。我们必须使一致性模型更宽松来有效描述并发。现在，进程可以从其他任意进程读到最近写入的值。寄存器变成了两个进程之间的协调地：它们共享了状态。
2. 我们的操作不再是瞬时的。在几乎每个实际的系统中，进程之间都有一定的距离。一个没有被缓存的值（指没有被CPU的local cache缓存），通常在距离CPU30厘米的DIMM内存条上。光需要整整一个纳秒来传播这么长的距离，实际的内存访问会比光速慢得多。位于不同数据中心某台计算机上的值可以相距几千公里——意味着需要几百毫秒的传播时间。bottom发起一个读请求的时候，值为a，但在读请求的传播过程中，top将值写为b——写操作偶然地比读请求先到达寄存器。Bottom最终读到了b而不是a，Bottom并没有读到它在发起读请求时的值。有人会考虑使用完成时间而不是调用时间作为操作的真实时间，但反过来想想，这同样行不通：当读请求比写操作先到达时，进程会在当前值为b时读到a。PS：当你以为你读a（你之前写的）的时候有人正试图写入b，所以你想读到a还是b？
在分布式系统中，操作的耗时被放大了，我们必须使一致性模型更宽松：允许这些有歧义的顺序发生。我们该如何确定宽松的程度？我们必须允许所有可能的顺序吗？或许我们还是应该强加一些合理性约束？
1. 线性一致性，基于硬件提供可线性化的操作CAS，当且仅当寄存器持有某个值的时候，我们可以往它写入新值（原子性约束来安全地修改状态）。线性一致性的时间界限保证了操作完成后，所有变更都对其他参与者可见。线性一致性禁止了过时的读。每次读都会读到某一介于调用时间与完成时间的状态，但永远不会读到读请求调用之前的状态。线性一致性同样禁止了非单调的读，比如一个读请求先读到了一个新值，后读到一个旧值。线性一致性模型提供了这样的保证：1.对于观察者来说，所有的读和写都在一个单调递增的时间线上串行地向前推进。2.所有的读总能返回最近的写操作的值。
2. 顺序一致性放松了对一致性的要求：1. 不要求操作按照真实的时间序发生。2. 不同进程间的操作执行先后顺序也没有强制要求，但必须是原子的。3. 单个进程内的操作顺序必须和编码时的顺序一致。很多缓存的行为和顺序一致性系统一致。如果我在Twitter上写了一条推文，或是在Facebook发布了一篇帖子，都会耗费一定的时间渗透进一层层的缓存系统。不同的用户将在不同的时间看到我的信息，但每个用户都以同一个顺序看到我的操作。一旦看到，这篇帖子便不会消失。如果我写了多条评论，其他人也会按顺序的看见，而非乱序。PS：我10点写一篇帖子，你可以10点去看的时候没看到。
3. 因果一致性。我们不必对一个进程内的每个操作都施加顺序约束，只有因果相关的操作必须按顺序发生。因果一致性比同一进程下对每个操作严格排序的一致性（即顺序一致性）来的更宽松——属于同一进程但不同因果关系链的操作能以相对的顺序执行（也就是说按因果关系隔离，无因果关系的操作可以并发执行），这能防止许多不直观的行为发生。PS：我10点、11点都发了一篇帖子并对帖子1评论，你可以11点看到了帖子2但没看到帖子1，但是不能帖子1没看到，帖子1的评论看到了。

“弱”一致性模型比“强”一致性模型允许更多的操作记录发生（这里的强与弱是相对的）。比如线性一致性保证操作在调用时间与完成时间之间发生。不管怎样，需要协调来达成对顺序的强制约束。不严格地说，执行越多的记录，系统中的参与者就必须越谨慎且通信频繁。

自己理解： top编码顺序abc，bottom编码顺序123，假设3必须在2之后，b和2读写同一个变量。 完全乱序有`6*5*4*3*2*1`种可能；因果一致性限定了3必须在2之后，有`6*5*4*3*2/2`种可能；顺序一致性限定了abc和123的编码顺序，有`6*5*4*3*2/3*2*1/2/2`；线性一致性限定了2和b必须紧挨在一起，干掉了bc2 bc12 b12 b1c2 2ab 23ab 23b 23ab这8中可能，有`6*5*4*3*2/3*2*1/2/2/8`。如果有协调者，则top和bottom 就按照协调者制定的唯一顺序运行。


bc2 bc12 b12 b1c2 2ab 23ab 23b 23ab

### 一致性算法

下面看下 《区块链核心算法解析》 中的思维线条

1. 两节点

	1. 客户端服务端，如何可靠通信？如何处理消息丢失问题
	2. 请求-确认，客户端一段时间收不到 确认则重发，为数据包标记序列号解决重发导致的重复包问题。这也是tcp 的套路

2. 单客户端-多服务端
3. 多客户端-多服务端

	1. 多服务端前 加一个 单一入口（串行化器）， 所以的客户端先发给 串行化器，再分发给服务端。即主从复制思路==> 串行化器单点问题
	2. 客户端先协调好，由一个客户端发命令

		1. 抽取独立的协调器。2pc/3pc 思路
		2. 客户端向所有的服务端申请锁，谁先申请到所有服务器的锁，谁说了算。缺点：客户端拿到锁后宕机了，尴尬！
		3. 票的概念，弱化形式的锁。paxos 套路（当然，具体细节更复杂）
		4. 广播多轮投票。随机共识算法，不准确描述：假设只对01取得共识，第一轮每个节点随机选定一个值，广播给其它所有节点，节点收到超过半数其它节点的值，如果恰好是同一个值，则节点改变自己本轮的“意见”，重新广播该值。

tips

1. paxos 无法保证确定性，即理论上存在一直无法达成一致、不停地投票的情况
2. paxos/随机共识算法等 假定 参与节点都按规则 运行
3. 《分布式协议与算法实战》Basic Paxos 实现了**容错**，在少于一半的节点出现故障时，集群也能工作。它不像分布式事务算法那样，必须要所有节点都同意后才提交操作，因为“所有节点都同意”这个原则，在出现节点故障的时候会导致整个集群不可用。

### 基于拜占庭节点的一致性

[漫谈分布式系统、拜占庭将军问题与区块链](http://zhangtielei.com/posts/blog-consensus-byzantine-and-blockchain.html)拜占庭节点：节点可能不按规则行事，甚至故意发送错误数据，多个拜占庭节点也可能串谋。

基于拜占庭节点达成共识

1. 拜占庭容错（BFT）算法，一系列算法的统称。网络中节点的数量和身份必须是提前确定好的
2. POW，间接共识，先选谁说了算，再达成共识。

    1. 这个算法具有不对称性，也就是说，工作对于请求方是有难度的，对于验证方则是比较简单的，易于验证的。
    2. 计算出符合条件的哈希值后，矿工就会把这个信息广播给集群中所有其他节点，其他节点验证通过后，会将这个区块加入到自己的区块链中，最终形成一串区块链
    3. 如果攻击者掌握了较多的算力，能挖掘一条比原链更长的攻击链，并将攻击链向全网广播，这时呢，按照约定，节点将接受更长的链，也就是攻击链，丢弃原链。

解决拜占庭问题，笔者感觉有几个点

1. 消息签名：签名消息约束了叛徒的作恶行为，比如，叛徒可以不响应，可以相互勾结串通，但叛徒无法篡改和伪造忠将的消息。
1. 广播和转发，一个将军的命令发给所有其它将军，A将收到的B 将军的信息也转发给其他所有将军。从信息论的角度来说，就是信息尽可能的冗余。熵是对不确定性的度量。从控制论的角度来看，应叫不确定性。当我们不知道某事物具体状态，却知道它有几种可能性时，显然，可能性种类愈多，不确定性愈大。不确定性愈大的事物，我们最后确定了、知道了，这就是说我们从中得到了愈多的信息，也就是信息量大。

区块链到底是什么？有人说是个无法篡改的超级账本，也有人说是个去中心化的交易系统，还有人说它是构建数字货币的底层工具。但是，从技术的角度来说，它首先是个解决了拜占庭将军问题的分布式网络，**在完全开放的环境中，实现了数据的一致性和安全性。而其它的属性，都附着于这一技术本质之上。**

## 两阶段提交

二阶段提交协议，不仅仅是协议，也是一种非常经典的思想。二阶段提交在达成提交操作共识的算法中应用广泛，比如 XA 协议、TCC、Paxos、Raft 等。在分布式系统中，为了让每个节点都能够感知到其他节点的情况，会进行多轮协商，“先搞清楚大家的想法再做决定”。所以不管是为了事务一致性，还是副本数据一致性，都有prepare 和 commit 的影子在。

1. 如果没有 一个中心化的协调者 coordinator角色存在的话，每个节点都要与其它节点 进行两轮以上的通信。
2. 如果有一个中心化的协调者coordinator角色，则由 coordinator 担任 “话事人”，每个participant 只需与coordinator 沟通即可（两轮以上）。网络中节点的数量和身份可以是提前确定好的，也或者干活前先推举一个“话事人”。

就好像连通n台服务器，要么两两都相连，要么大家都连在“交换机”上。

协商的事情越复杂，人员构成越复杂，协商的次数、消息数量越多。协商2次 只是很理想的场景。






## 怎样舍弃一致性提升性能？

服务的性能，主要体现在请求的时延和系统的并发性这两个方面，我通常会把分布式系统分为纵向、横向两个维度，其中纵向是请求的处理路径，横向则是同类服务之间的数据同步路径。这样，在纵向上在离客户端更近的位置增加数据的副本，并把它存放在处理速度更快的物理介质上，就可以作为缓存降低请求的时延；而在横向上对数据增加副本，并在这些主机间同步数据，这样工作在数据副本上的进程也可以同时对客户端提供服务，这就增加了系统的并发性。

![](/public/upload/distribute/performance.png)